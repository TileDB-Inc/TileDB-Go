// Program sizegen generates a Go file containing the byte size of variables
// of each Go numeric type, to be used in `go generate`.
package main

import (
	"flag"
	"fmt"
	"go/format"
	"go/parser"
	"os"
	"path/filepath"
	"strings"
)

var (
	outFlag = flag.String("out", "", "The file to write the output to. The package name is derived from the path to this file.")
	pkgFlag = flag.String("pkg", "", "The package name to write to. If not present, uses the directory name.")
	expFlag = flag.Bool("export", false, "True if the symbols should be exported (capital name); false otherwise.")
	sufFlag = flag.String("suffix", "Bytes", "The suffix to place on each size's name, e.g. Uint8Suffix.")

	kinds = []string{
		// Architecture-dependent types.
		"int(0)",
		"uint(0)",
		"uintptr(0)",
		// Architecture-independent integral types.
		"bool(false)",
		"int8(0)",
		"int16(0)",
		"int32(0)",
		"int64(0)",
		"uint8(0)",
		"uint16(0)",
		"uint32(0)",
		"uint64(0)",
		// Floating-point and complex types.
		"float32(0)",
		"float64(0)",
		"complex64(0)",
		"complex128(0)",
	}
	aliases = []string{
		"byte=uint8",
		"rune=int32",
	}
)

// name constructs the name of the constant for the given type.
func name(typ string, suf string, exported bool) string {
	if exported {
		typ = strings.Title(typ)
	}
	return typ + suf
}

func main() {
	flag.Parse()
	if *outFlag == "" {
		fmt.Fprint(os.Stderr, "the output filename must be specified.\n")
		flag.Usage()
		os.Exit(2)
	}
	pkgName := *pkgFlag
	if pkgName == "" {
		absPath, err := filepath.Abs(*outFlag)
		if err != nil {
			fmt.Fprintf(os.Stderr, "could not determine absolute path to %q: %v\n", *outFlag, err)
			os.Exit(1)
		}
		pkgDir := filepath.Dir(absPath)
		pkgName = filepath.Base(pkgDir)
	}

	if _, err := format.Source([]byte("package " + pkgName)); err != nil {
		fmt.Fprintf(os.Stderr, "%q is an invalid package name\n", pkgName)
		os.Exit(2)
	}

	sampleName := name("Thing", *sufFlag, false)
	if _, err := parser.ParseExpr(sampleName); err != nil {
		fmt.Fprintf(os.Stderr, "%q is an invalid suffix\n", *sufFlag)
		os.Exit(2)
	}

	dirty := generate(pkgName, *sufFlag, *expFlag)
	clean, err := format.Source([]byte(dirty))
	if err != nil {
		// This should never happen, so panic.
		panic(fmt.Sprintf("generated invalid source code: %v", err))
	}
	outFile, err := os.Create(*outFlag)
	if err != nil {
		fmt.Fprintf(os.Stderr, "could not open output file: %v\n", err)
		os.Exit(1)
	}
	defer outFile.Close()
	if _, err := outFile.Write(clean); err != nil {
		fmt.Fprintf(os.Stderr, "could not write source code: %v\n", err)
		os.Exit(1)
	}
}

func generate(pkgName, suffix string, export bool) string {
	// Build the two arrays we use to populate the generated file.

	// The array of WhateverBytes = uint64(...)
	var constArray []string
	// The array for the kind map reflect.Whatever: WhateverBytes,
	var kindMap []string
	for _, literal := range kinds {
		kind := strings.Split(literal, "(")[0]
		constName := name(kind, suffix, export)
		constArray = append(constArray, fmt.Sprintf("%s = uint64(unsafe.Sizeof(%s))", constName, literal))
		kindMap = append(kindMap, fmt.Sprintf("reflect.%s: %s,", strings.Title(kind), constName))
	}
	for _, pair := range aliases {
		split := strings.Split(pair, "=")
		alias, canon := split[0], split[1]
		constArray = append(constArray, fmt.Sprintf("%s=%s", name(alias, suffix, export), name(canon, suffix, export)))
	}

	out := []string{
		"// This file was generated by sizegen. DO NOT EDIT.",
		"",
		fmt.Sprintf("package %s", pkgName),
		"",
		"import (",
		"\"reflect\"",
		"\"unsafe\"",
		")",
		"",
		"// Constants for the byte size of each Go numeric type.",
		"const (",
	}

	out = append(out, constArray...)

	mapName := name("kind", suffix, export)

	out = append(
		out,
		")",
		"",
		fmt.Sprintf("// %s maps each numeric reflect.Kind to the number of bytes it takes.", mapName),
		"// Non-numeric kinds and aliases are not included.",
		fmt.Sprintf("var %s = map[reflect.Kind]uint64 {", mapName),
	)
	out = append(out, kindMap...)
	out = append(
		out,
		"}",
	)

	return strings.Join(out, "\n")
}
